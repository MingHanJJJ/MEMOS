memos-1.s:89: Warning: 00000000534d4150 shortened to 0000000000004150
memos-1.s:95: Error: bad register name `%rax'
memos-1.s:96: Error: bad register name `%rax'



do_e820:
        movl $0x8004, %edi           # Set di to 0x8004
        xorl %ebx, %ebx              # ebx must be 0 to start
        xorw %bp, %bp                # keep an entry count in bp
        movl $0x0534D4150, %edx      # Place "SMAP" into edx
        movl $0xE820, %eax
        movl $1,  %es:20(%di)        # force a valid ACPI 3.X entry
        movl $24, %ecx               # ask for 24 bytes
        int $0x15
        jc .failed                   # carry set on first call means "unsupported function"
        movl $0x0534D4150, %edx      # Some BIOSes apparently trash this register?
        cmpl %edx, %eax              # on success, eax must have been reset to "SMAP"
        jne .failed
        testl %ebx, %ebx             # ebx = 0 implies list is only 1 entry long (worthless)
        je .failed
        jmp .jmpin

.e820lp:
        movl $0xe820, %eax           # eax, ecx get trashed on every int 0x15 call
        movl $1,  %es:20(%di)        # force a valid ACPI 3.X entry
        movl $24, %ecx               # ask for 24 bytes again
        int $0x15
        jc .e820f                    # carry set means "end of list already reached"
        movl $0x0534D4150, %edx      # repair potentially trashed register

.jmpin:
        jcxz .skipent                # skip any 0 length entries
        cmpl $20, %ecx                # got a 24 byte ACPI 3.X response?
        jbe .notext
        testb $1,  %es:20(%di)       # if so: is the "ignore this data" bit clear?
        je .skipent

.notext:
        movb %es:20(%di), %cl          # load the byte at ES:DI into %cl
        movl $0x0E, %ah              # Set AH to 0x0E for BIOS Teletype output
        int $0x10
        movl  %es:8(%di), %ecx        # get lower uint32_t of memory region length
        orl  %es:12(%di), %ecx        # "or" it with upper uint32_t to test for zero
        jz .skipent                  # if length uint64_t is 0, skip entry
        incw %bp                      # got a good entry: ++count, move to next storage spot
        addl $24, %di

.skipent:
        testl %ebx, %ebx             # if ebx resets to 0, list is complete
        jne .e820lp

.e820f:
        movw %bp, mmap_ent           # store the entry count
        clc                           # there is "jc" on end of list to this point, so the carry must be cleared
        ret

.failed:
        stc                           # "function unsupported" error exit
        ret



print_address_len:
        call write_0x
        movw %es:14(%di), %ax          # load the 2 bytes at ES:DI into %ax
        call print_2byte_in_ax
        movw %es:12(%di), %ax          # load the 2 bytes at ES:DI into %ax
        call print_2byte_in_ax
        movw %es:10(%di), %ax          # load the 2 bytes at ES:DI into %ax
        call print_2byte_in_ax
        movw %es:8(%di), %ax           # load the 2 bytes at ES:DI into %ax
        call print_2byte_in_ax
        ret
